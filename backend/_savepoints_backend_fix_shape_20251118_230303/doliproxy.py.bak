import os
from typing import Any, Dict, Optional, Tuple

import httpx
from fastapi import APIRouter

router = APIRouter(tags=["Dolibarr"])


def _get_dolibarr_base_and_key() -> Tuple[str, Optional[str]]:
    """
    Read Dolibarr base URL and API key from env.
    DOLI_API_URL example: http://host.docker.internal:8282/api/index.php
    This function NEVER raises HTTP exceptions. It only returns (base, key or None).
    """
    base = os.getenv("DOLI_API_URL") or "http://host.docker.internal:8282/api/index.php"
    key = os.getenv("DOLI_API_KEY")
    return base.rstrip("/"), key


async def _call_dolibarr(path: str, params: Optional[Dict[str, Any]] = None) -> Tuple[bool, Any]:
    """
    Generic helper to call Dolibarr REST API and return (ok, data_or_error).
    It NEVER raises HTTPException. All errors are converted to (False, message).
    On success: (True, json or text).
    """
    base, key = _get_dolibarr_base_and_key()

    if not key:
        return False, "DOLI_API_KEY is not set"

    url = f"{base}/{path.lstrip('/')}"
    q: Dict[str, Any] = dict(params or {})
    q["DOLAPIKEY"] = key

    timeout = httpx.Timeout(10.0, connect=5.0)

    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            resp = await client.get(url, params=q)
    except httpx.RequestError as exc:
        return False, f"Dolibarr unreachable: {exc}"

    if resp.status_code != 200:
        return False, f"Dolibarr error {resp.status_code}: {resp.text}"

    try:
        return True, resp.json()
    except ValueError:
        # Fallback: return raw text if JSON parsing fails
        return True, resp.text


@router.get("/health/dolibarr")
async def health_dolibarr() -> Dict[str, Any]:
    """
    Simple health-check against Dolibarr.
    It NEVER returns HTTP 5xx. If Dolibarr is not configured or broken,
    status will be "error" instead of raising.
    """
    ok, _ = await _call_dolibarr("thirdparties", params={"limit": 1})
    if ok:
        return {"status": "ok"}
    return {"status": "error"}


@router.get("/clients")
async def list_clients(limit: int = 100, page: int = 0) -> Any:
    """
    Map /clients -> Dolibarr /thirdparties.
    On any error returns an empty list [] with HTTP 200.
    """
    params = {
        "limit": limit,
        "page": page,
        "sortfield": "t.rowid",
        "sortorder": "ASC",
    }
    ok, data = await _call_dolibarr("thirdparties", params=params)

    if not ok:
        # Safe fallback: backend stays alive, client sees an empty list.
        return []

    # Normalize to list
    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        items = data.get("items")
        if isinstance(items, list):
            return items
    return []


@router.get("/invoices")
async def list_invoices(limit: int = 100) -> Any:
    """
    Map /invoices -> Dolibarr /invoices.
    On any error returns an empty list [] with HTTP 200.
    """
    params = {
        "limit": limit,
    }
    ok, data = await _call_dolibarr("invoices", params=params)

    if not ok:
        return []

    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        items = data.get("items")
        if isinstance(items, list):
            return items
    return []


@router.get("/products")
async def list_products(limit: int = 100) -> Any:
    """
    Map /products -> Dolibarr /products.
    On any error returns an empty list [] with HTTP 200.
    """
    params = {
        "limit": limit,
    }
    ok, data = await _call_dolibarr("products", params=params)

    if not ok:
        return []

    if isinstance(data, list):
        return data
    if isinstance(data, dict):
        items = data.get("items")
        if isinstance(items, list):
            return items
    return []
