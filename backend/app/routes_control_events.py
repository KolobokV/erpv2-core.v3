from __future__ import annotations

from datetime import date
from typing import List, Optional

from fastapi import APIRouter, HTTPException, Query
from pydantic import BaseModel, Field

from .control_events_service import generate_demo_events


router = APIRouter(
    prefix="/api",
    tags=["control-events"],
)


class ControlEventItem(BaseModel):
    id: str
    client_id: str = Field(..., description="Client identifier")
    title: str
    date: date
    category: str
    depends_on: Optional[str] = None


class ControlEventsResponse(BaseModel):
    client_id: str
    year: int
    month: int
    events: List[ControlEventItem]


def _map_kind_to_category(kind: str) -> str:
    """Map internal kind to simple category for UI."""
    if kind == "bank_statement_request":
        return "bank"
    if kind == "primary_documents_request":
        return "documents"
    if kind == "salary_payment":
        return "salary"
    if kind == "tax_payment":
        return "tax"
    return kind


@router.get(
    "/control-events/{client_id}",
    response_model=ControlEventsResponse,
    summary="Get control events for client and period",
)
async def get_control_events_for_client(
    client_id: str,
    year: int = Query(..., ge=2000, le=2100, description="Year, e.g. 2025"),
    month: int = Query(..., ge=1, le=12, description="Month number 1-12"),
) -> ControlEventsResponse:
    """
    Return list of control events for a given client and month.

    External response format is stable:
    {
        "client_id": "...",
        "year": 2025,
        "month": 12,
        "events": [
            {
                "id": "...",
                "client_id": "...",
                "title": "...",
                "date": "YYYY-MM-DD",
                "category": "bank | documents | salary | tax",
                "depends_on": "..." | null
            }
        ]
    }

    Internal events are generated by control_events_service.
    """
    try:
        raw_events = generate_demo_events(
            client_id=client_id,
            year=year,
            month=month,
        )
    except ValueError as exc:
        raise HTTPException(status_code=400, detail=str(exc)) from exc

    items: List[ControlEventItem] = []

    # First pass: create items without depends_on
    for raw in raw_events:
        event_id = raw.get("id")
        event_client_id = raw.get("clientId", client_id)
        title = raw.get("title", event_id or "")
        event_date = raw.get("date")
        kind = raw.get("kind", "")
        category = _map_kind_to_category(kind)

        item = ControlEventItem(
            id=event_id,
            client_id=event_client_id,
            title=title,
            date=event_date,
            category=category,
            depends_on=None,
        )
        items.append(item)

    # Second pass: simple dependency example
    # If there is a "documents" event and a "bank" event in the same period,
    # we can mark documents event as depending on bank event.
    bank_event_id: Optional[str] = None
    for item in items:
        if item.category == "bank":
            bank_event_id = item.id
            break

    if bank_event_id:
        for item in items:
            if item.category == "documents":
                item.depends_on = bank_event_id

    response = ControlEventsResponse(
        client_id=client_id,
        year=year,
        month=month,
        events=items,
    )
    return response
